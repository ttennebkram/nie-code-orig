package nie.core;

import java.io.*;
import java.util.*;

import org.jdom.Document;
import org.jdom.Element;
import org.jdom.CDATA;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.jdom.JDOMException;

import org.jdom.transform.*;
import javax.xml.transform.*;
import javax.xml.transform.stream.*;

/**
 * <p><code>JDomUtil</code></p> encapsulates some shortcuts
 * for creating objects around JDom.
 * </p>
 * <p>Originally classes were derived from this class, so the functions
 * were implemented that way.  Now you can also do a "has a" vs "is a"
 * mode, see Constructor # 4.
 * </p>
 * Copyright 2001 New Idea Engineering, Inc.
 * {@link www.ideaeng.com}
 * @author Mark Bennett (mbennett@ideaeng.com)
 * @version 0.1
 **/


public class JDOMHelper implements Cloneable
{

//  Moved to it's own file
//	public class JDOMHelperException extends Exception
//	{
//		public JDOMHelperException( String inMessage )
//		{
//			super( inMessage );
//		}
//	}

	// The name of the top level element
	// OVERRIDE THIS if you want to have us check.
	// Of course you can only override this if you are inheriting
	// from it.
	// Have it return null if you don't want this check performed.
	// return a white space separated list if you will accept multiple ones

	public String _getDesiredTopLevelElementName()
	{
		// Will normally be NULL, which will casue an error,
		// so you should really override.

		return null;
	}

	private static final boolean debug = false;

	/**********************************************
	 *
	 *		Member Variables
	 *
	 ***********************************************/

	// WARNING!!!!!!
	// We implement cloneable, so remember to update the clone
	// method if you add non-static, mutable member variables

	// The main element that defines this object
	private Element myElement = null;
	// Optional: if read from a file/url, where was it?
	private String sourceURI = null;
	// Optional: if a parser or document was constructed, save it
	private static SAXBuilder jdomBuilder = new SAXBuilder();
	private Document jdomDocument = null;
	// A cache for attribute lists
	// Assumes READ ONLY
	private Hashtable attrListCache = null;


	/**********************************************
	 *
	 *		Constructors
	 *
	 ***********************************************/

	/**
	 * Constructor # 1: Create from an existing element.
	 * <p>
	 * This will create an instance of a <code>JDOMHelper</code>
	 * </p>
	 *
	 * @param jdom Element <code>element</code>
	 * An element describing the Stream to create.
	 **/

	public JDOMHelper( Element inputElement )
		throws JDOMHelperException
	{
		_jdomInit( inputElement );
		// Can't use this() because other constructors
	}

	/**
	 * Constructor # 2: Create from an XML file, given a filename or url
	 * <p>
	 * This will create an instance of a <code>JDOMHelper</code>
	 * </p>
	 *
	 * @param String <code>uri</code>
	 * Where to get the source document from
	 **/
	public JDOMHelper( String uri )
		throws JDOMHelperException
	{
		//synchronized( jdomBuilder )
		//{
		//  if( jdomBuilder == null )
		//		jdomBuilder = new SAXBuilder();
		//	jdomDocument = jdomBuilder.build(uri);
		//}
		try
		{
			jdomDocument = jdomBuilder.build(uri);
		}
		catch(JDOMException e)
		{
			jdomDocument = null;
			throw new JDOMHelperException(
				"jdh(uri): exception for uri '" + uri + "'"
				+ " error:" + e
				);
		}
		_jdomInit( jdomDocument.getRootElement() );
	}

	/*
	 * Constructor # 3: Create from an XML blob of text
	 * <p>
	 * Create an object from a string representation of an element.
	 * </p>
	 *
	 * @param String <code>XML text</code>, Builder <code>builder</code>
	 * null is OK for builder
	 */
	public JDOMHelper( String sourceString, SAXBuilder builder )
		throws JDOMHelperException
	{

		/* A little convoluted logic, but it makes sense.
		   If I pass you a builder, use it.
		   If I don't pass you a builder, see if there's already
		   one assigned to this object.
		   If none passed and none in object, create one.
		   And whatever you do, if you find the object's was
		   null, set it with whatever you come up with.
		*/
		//synchronized( jdomBuilder )
		//{
			if( builder == null )
			{
				if( jdomBuilder == null )
				{
					builder = new SAXBuilder();
					jdomBuilder = builder;
				}
				else
					builder = jdomBuilder;
			}
			else
				if( jdomBuilder == null )
					jdomBuilder = builder;
		//}   // End Sync block


		/* By this point, builder is pointed to something reasonable */

		// Create a character reader from the string

		StringReader sr = new StringReader( sourceString );
		try
		{
			jdomDocument = jdomBuilder.build(sr);
		}
		catch(JDOMException e)
		{
			jdomDocument = null;
			try { sr.close(); } catch (Exception e2) { }
			throw new JDOMHelperException(
				"jdh(from String): exception"
				+ " error:" + e
				);

		}

		try { sr.close(); } catch (Exception e2) { }
		sr = null;
		_jdomInit( jdomDocument.getRootElement() );
	}

	/*
	 * Constructor # 4: Create from a Java File object
	 * <p>
	 * Create an object from a Java File representation of an element.
	 * </p>
	 *
	 * @param File <code>XML file</code>
	 */
	public JDOMHelper( File inFile )
		throws JDOMHelperException
	{
		final boolean debug = false;
		if(debug)
		{
			System.err.println( "JDH const(file) start" );
			System.err.flush();
		}
//		synchronized( jdomBuilder )
//		{
//			//if( jdomBuilder == null )
//				jdomBuilder = new SAXBuilder();
//			if(debug)
//			{
//				System.err.println( "JDH const(file) B" );
//				System.err.flush();
//			}
//			jdomDocument = jdomBuilder.build( inFile );
//		}

		try
		{
			jdomDocument = jdomBuilder.build(inFile);
		}
		catch(JDOMException e)
		{
			jdomDocument = null;
			throw new JDOMHelperException(
				"jdh(File): exception"
				+ " error:" + e
				);
		}

//		//jdomDocument = jdomBuilder.build( inFile.getCanonicalPath() );
//		String tmpName = inFile.getCanonicalPath();
//		System.err.println( "before: " + tmpName );
//		tmpName = tmpName.replace( '\\', '/' );
//		System.err.println( "after: " + tmpName );
//		//tmpName = "/test/cisco_cache_small/wu_10007.xml";
//		tmpName = tmpName.substring( 2 );
//		System.err.println( "and then: " + tmpName );
//		jdomDocument = jdomBuilder.build( tmpName );
		if(debug)
		{
			System.err.println( "JDH const(file) C" );
			System.err.flush();
		}
		if( jdomDocument == null )
			throw new JDOMHelperException(
				"jdh(inFile): null document from File '" + inFile + "'"
				);
		if(debug)
		{
			System.err.println( "JDH const(file) D" );
			System.err.flush();
		}
		_jdomInit( jdomDocument.getRootElement() );
		if(debug)
		{
			System.err.println( "JDH const(file) end" );
			System.err.flush();
		}
	}

	/**
	 * Constructor # 5: Create from an InputStream
	 * <p>
	 * This will create an instance of a <code>JDOMHelper</code>
	 * </p>
	 *
	 * @param InputStream <code>inStream</code>
	 * Where to get the source document from
	 * REMEMBER TO CLOSE YOUR STREAM!!!!!
	 **/
	public JDOMHelper( InputStream inStream )
		throws JDOMHelperException
	{
//		synchronized( jdomBuilder )
//		{
//			//if( jdomBuilder == null )
//				jdomBuilder = new SAXBuilder();
//			jdomDocument = jdomBuilder.build( inStream );
//		}

		try
		{
			jdomDocument = jdomBuilder.build(inStream);
		}
		catch(JDOMException e)
		{
			jdomDocument = null;
			throw new JDOMHelperException(
				"jdh(Stream): exception"
				+ " error:" + e
				);
		}

		if( jdomDocument == null )
			throw new JDOMHelperException(
				"jdh(inStream): null document from stream '" +
				inStream + "'"
				);

		_jdomInit( jdomDocument.getRootElement() );

		//jdomDocument.getRootElement().detach();
	}



	/*
	 * Constructor # 6: default constructor
	 */

	public JDOMHelper()
		throws JDOMHelperException
	{
		//synchronized( jdomBuilder )
		//{
			//if( jdomBuilder == null )
			//	jdomBuilder = new SAXBuilder();
			jdomDocument = new Document( new Element("root") );
		//}
		_jdomInit( jdomDocument.getRootElement() );
	}

	private void _jdomInit( Element inputElement )
		throws JDOMHelperException
	{
		if( inputElement == null )
			throw new JDOMHelperException( "Null element passed in to init." );

		// Store the reference to our jdom element
		myElement = inputElement;

		String desiredElementName = _getDesiredTopLevelElementName();
		if( desiredElementName != null )
		{
			boolean haveSeenValidName = false;
			String buffer = desiredElementName;
			StringTokenizer st = new StringTokenizer( buffer );
			while( st.hasMoreTokens() )
			{
				String item = st.nextToken();

				// todo: revisit case sensitivity, probably bad, would also
				// have to change logic in dpapp
				//item = item.trim().toLowerCase();

				if( item != null && ! item.equals("") )
				{
					if( getElementName().equals(item) )
					{
						haveSeenValidName = true;
						break;
					}
				}
			}
			if( ! haveSeenValidName )
				throw new JDOMHelperException(
					"Expected the element name to match in '" +
					desiredElementName + "' but got a '" +
					inputElement.getName() + "' element instead."
					);
		}  // end if have a desired name

	}

	// Do a "deep" clone
	public synchronized Object clone()
	{

		// Cloning should take place in a try block
		try
		{
			// Get a default clone of myself
			JDOMHelper me2 = (JDOMHelper)(super.clone());

			// Duplicate memeber variables

			// If we have a document, we need to reproduce both
			// the document and the my element variable
			// in the proper order
			if( jdomDocument != null )
			{
				// Clone the document
				me2.jdomDocument = (Document)jdomDocument.clone();
				// Just adjust the reference to the new document
				// in the clone
				if( myElement != null )
					me2.myElement = (Element)me2.jdomDocument.getRootElement();
			}
			// Else we didn't have a document
			// but we probably still have an element
			else
			{
				if( myElement != null )
					me2.myElement = (Element)myElement.clone();
			}

			if( attrListCache != null )
				me2.attrListCache = (Hashtable)attrListCache.clone();

			// sourceURI is an immutable string
			// SAXBuilder is static
			// debug is static

			return me2;

		}
		catch (CloneNotSupportedException e)
		{
			System.err.println( "JDOMHelper: clone failed\n" + e );
			return this;
		}

	}

	/********************************************
	 *
	 *		Simple Get / Set Methods
	 *
	 *********************************************/

	private void __sep__Simple_Get_Set_Methods__() {}

	public Element getJdomElement()
	{
		return myElement;
	}

	public String getElementName()
	{
		return getJdomElement().getName();
	}

	public String getTextTrim()
	{
		return getJdomElement().getTextTrim();
	}

	public String getTextTrimOrNull()
	{
		String tmpStr = getJdomElement().getText();
		tmpStr = NIEUtil.trimmedStringOrNull( tmpStr );
		return tmpStr;
	}

	public String getTextSuperTrimOrNull()
	{
		String tmpStr = getJdomElement().getTextNormalize();
		tmpStr = NIEUtil.trimmedStringOrNull( tmpStr );
		return tmpStr;
	}

	public List getJdomChildren()
	{
		return getJdomElement().getChildren();
	}

	public int getJdomChildrenCount()
	{
		return getJdomChildren().size();
	}

	public Element getJdomChildByOffset( int i )
	{
		return (Element)getJdomChildren().get(i);
	}

	public String getClassName()
	{
		return this.getClass().getName();
	}

	// void setDesiredTopLevelElementName( String target )
	// {
	//		 acceptableName = target;
	// }
	// no way to call this before constructor, don't feel like
	// complicating constructors right now.


	private void __sep__Simple_JDOM_Wrappers_() {}
	public Element addContent( JDOMHelper newNode )
	{
		return addContent( this, newNode );
	}
	public static Element addContent( JDOMHelper inParent,
		JDOMHelper inNewChild
		)
	{
		if( inParent==null || inNewChild==null )
		{
			System.err.println( "ERROR:JDOMHelper:addContent(j,j):"
				+ " Null inputs."
				+ " inParent=" + inParent
				+ " inNewChild=" + inNewChild
				);
		}
		Element parent = inParent.getJdomElement();
		Element child = inNewChild.getJdomElement();
		child.detach();
		return parent.addContent( child );
	}
	public Element addContent( Element newNode )
	{
		return addContent( this, newNode );
	}
	public static Element addContent( JDOMHelper inParent, Element inNewChild )
	{
		if( inParent==null || inNewChild==null )
		{
			System.err.println( "ERROR:JDOMHelper:addContent(j,e):"
				+ " Null inputs."
				+ " inParent=" + inParent
				+ " inNewChild=" + inNewChild
				);
		}
		Element parent = inParent.getJdomElement();
		inNewChild.detach();
		return parent.addContent( inNewChild );
	}


	public static Element addContent( Element inParent, JDOMHelper inNewChild )
	{
		if( inParent==null || inNewChild==null )
		{
			System.err.println( "ERROR:JDOMHelper:addContent(e,j):"
				+ " Null inputs."
				+ " inParent=" + inParent
				+ " inNewChild=" + inNewChild
				);
		}
		Element child = inNewChild.getJdomElement();
		child.detach();
		return inParent.addContent( child );
	}

	/********************************************************
	 *
	 *		Help with Reading and Writing Attributes
	 *
	 *********************************************************/
	private void __sep__Reading_and_Writing_Attributes() {}

	// When requesting a string, do NOT look for plural by default

	public String getStringFromAttribute( String target )
	{
		return getStringFromAttribute( myElement, target, false );
	}
	public static String getStringFromAttribute( Element elem, String target )
	{
		return getStringFromAttribute( elem, target, false );
	}

	// These versions trim strings and force empty strings to nulls
	public String getStringFromAttributeTrimOrNull( String target )
	{
		return getStringFromAttributeTrimOrNull( myElement, target, false );
	}
	public static String getStringFromAttributeTrimOrNull( Element elem, String target )
	{
		return getStringFromAttributeTrimOrNull( elem, target, false );
	}

	// Get a string, optionally check for plural form
	// We always prefer the singular form

	public String getStringFromAttribute( String target,
		boolean allowPlural )
	{
		return getStringFromAttribute( myElement, target, allowPlural );
	}
	public String getStringFromAttributeTrimOrNull( String target,
		boolean allowPlural )
	{
		return getStringFromAttributeTrimOrNull( myElement, target, allowPlural );
	}
	public static String getStringFromAttribute( Element elem, String target,
		boolean allowPlural )
	{

		String tmp = null;
		tmp = elem.getAttributeValue(target);
		if( tmp == null && allowPlural )
			tmp = elem.getAttributeValue( target+"s" );
		return tmp;
	}
	public static String getStringFromAttributeTrimOrNull( Element elem,
		String inTarget, boolean inAllowPlural
		)
	{
		String tmpStr = null;
		tmpStr = elem.getAttributeValue( inTarget );
		tmpStr = NIEUtil.trimmedStringOrNull( tmpStr );
		if( tmpStr == null && inAllowPlural )
		{
			tmpStr = elem.getAttributeValue( inTarget + "s" );
			tmpStr = NIEUtil.trimmedStringOrNull( tmpStr );
		}
		return tmpStr;
	}

	public boolean setAttributeString( String attrName, String attrValue )
	{
		return setAttributeString( getJdomElement(), attrName, attrValue );
	}
	public static boolean setAttributeString( Element elem, String attrName,
		String attrValue
		)
	{
		if( elem==null || attrName==null || attrName.trim().equals("")
			|| attrValue==null
			)
		{
			System.err.println( "ERROR: JDOMHelper: setAttributeString:"
				+ " Null/empty values input."
				+ " elem=" + elem
				+ " attrName=" + attrName
				+ " attrValue=" + attrValue
				+ " (attrValue can be an empty string, but not a true NULL)"
				);
			return false;
		}
		attrName = attrName.trim();
		elem.setAttribute( attrName, attrValue );
		return true;
	}

	public boolean setAttributeStringForPath(
		String inPath, String inAttrName, String inAttrValue
		)
	{
		return setAttributeStringForPath(
			getJdomElement(),
			inPath, inAttrName, inAttrValue
			);
	}
	public static boolean setAttributeStringForPath(
		Element inStartElem,
		String inPath, String inAttrName, String inAttrValue
		)
	{
		if( inStartElem==null || inPath==null
			|| inAttrName==null || inAttrValue==null
			)
		{
			System.err.println( "ERROR:JDOMHelper:setAttributeStringForPath:"
				+ " Was passed NULL argument(s)."
				+ " inStartElem=" + inStartElem
				+ " inPath=" + inPath
				+ " inAttrName=" + inAttrName
				+ " inAttrValue=" + inAttrValue
				);
			return false;
		}

		Element destElem = findElementByPath( inStartElem, inPath );
		if( destElem == null )
			return false;

		destElem.setAttribute( inAttrName, inAttrValue );

		return true;
	}


	public static boolean decodeBooleanString( String inData, boolean defaultValue )
	{
		if( inData == null || inData.trim().equals("") )
			return defaultValue;

		inData = inData.trim().toLowerCase();

		// Todo: other ideas: good, pass, passed
		if( inData.equals("1") ||
			inData.equals("yes") || inData.equals("y") ||
			inData.equals("true") || inData.equals("t") ||
			inData.equals("affirmative") ||
			inData.equals("positive") || inData.equals("+")
			)
		{
			return true;
		}
		// Todo: other ideas: bad, fail, failed
		else if( inData.equals("0") ||
			inData.equals("no") || inData.equals("n") ||
			inData.equals("false") || inData.equals("f") ||
			inData.equals("negative") || inData.equals("-")
			)
		{
			return false;
		}
		else
		{
			System.err.println( "Warning: Jdh:decodeBoolean: unknown string"
				+ " \"" + inData + "\""
				+ " return default value \"" + defaultValue + "\""
				);
			return defaultValue;
		}
	}

	public boolean getBooleanFromAttribute( String target )
	{
		return getBooleanFromAttribute( myElement, target, false );
	}
	public static boolean getBooleanFromAttribute( Element elem, String target )
	{
		return getBooleanFromAttribute( elem, target, false );
	}

	public boolean getBooleanFromAttribute( String target,
		boolean defaultValue )
	{
		return getBooleanFromAttribute( myElement, target, defaultValue );
	}
	public static boolean getBooleanFromAttribute( Element elem,
		String target, boolean defaultValue
		)
	{
		if(debug)
			System.out.println( "		Debug: JDOMHelper:getBooleanFromAttribute(2): Start.\n\ttarget='" + target + "', default value='" + defaultValue + "'" );
		String tmpFlag = getStringFromAttribute( elem, target );
		if(debug)
			System.out.println( "Debug: JDOMHelper:getBooleanFromAttribute(2): tmpFlag='" + tmpFlag + "'" );
		if( tmpFlag == null || tmpFlag.trim().equals("") )
		{
			if(debug)
				System.out.println( "\tIt was null, returning default." );
			return defaultValue;
		}
		boolean answer = decodeBooleanString( tmpFlag, defaultValue );
		if(debug)
			if( answer )
				System.out.println( "\tit was a 1 or Yes or True, returning true" );
			else
				System.out.println( "\tit was NOT a 1 or Yes or True, so returning false" );
		return answer;
	}

	public int getIntFromAttribute( String target,
		int defaultValue )
	{
		return getIntFromAttribute( myElement, target, defaultValue );
	}
	public static int getIntFromAttribute( Element elem,
		String target, int defaultValue
		)
	{
		if(debug)
			System.out.println( "\tDebug: JDOMHelper:getIntFromAttribute(2): Start.\n\ttarget='" + target + "', default value='" + defaultValue + "'" );
		String tmpFlag = getStringFromAttribute( elem, target );
		if(debug)
			System.out.println( "Debug: JDOMHelper:getIntFromAttribute(2): tmpFlag='" + tmpFlag + "'" );
		if( tmpFlag == null || tmpFlag.trim().equals("") )
		{
			if(debug)
				System.out.println( "\tIt was null, returning default." );
			return defaultValue;
		}
		tmpFlag = tmpFlag.trim();
		int retValue = defaultValue;
		try
		{
			retValue = Integer.parseInt( tmpFlag );
		}
		catch(Exception e)
		{
			retValue = defaultValue;
		}

		return retValue;

	}

	// XML allows for a tag attribute to contain a LIST of
	// values, separated by white space.
	// These methods help manage that.

	// Will always return a list (assuming valid cache)

	public List getListFromAttribute( String target )
	{
		return getListFromAttribute( target, false );
	}

	public static List getListFromAttribute( Element elem, String target )
	{
		return getListFromAttribute( elem, target, false );
	}


	public List getListFromAttribute( String target,
		boolean allowPlural
		)
	{
		// Create the global cache table if it's not there

		if( attrListCache == null )
			attrListCache = new Hashtable();

		// Do we already know the answer?
		// No, calculate it and cache it

		if( ! attrListCache.containsKey(target) )
		{

			// Call the static version
			List retList = getListFromAttribute(
				myElement, target, allowPlural
				);

			// Cache the results
			attrListCache.put(target, retList);
		}

		// Return the answer

		return (List)attrListCache.get(target);
	}

	// This is the static version
	// Of course it does no caching
	// This also does the real work for the non-static version,
	// but the non-static version implements caching and wraps
	// that logic on top of this
	public static List getListFromAttribute( Element elem,
		String target, boolean allowPlural
		)
	{

		List retList = new Vector();
		String tmpStr = getStringFromAttribute( elem, target, allowPlural );
		if( tmpStr != null )
		{
			StringTokenizer st = new StringTokenizer( tmpStr );
			while( st.hasMoreTokens() )
			{
				String item = st.nextToken();
				item = item.trim().toLowerCase();
				if( ! item.equals("") )
				{
					if( ! retList.contains(item) )
						retList.add(item);
				}
			}
		}

		return retList;
	}


	// Given the name of an attribute that nornally contains one or
	// more values, separated by white space, does that list contain
	// a particular value?

	public boolean hasItemInAttrList( String listName,
		String target
		)
	{
		return hasItemInAttrList( listName, target, false );
	}

	public static boolean hasItemInAttrList( Element elem, String listName,
		String target
		)
	{
		return hasItemInAttrList( elem, listName, target, false );
	}

	public boolean hasItemInAttrList( String listAttrName,
		String targetAttrValue, boolean allowPlural
		)
	{
		String tmpTarget = targetAttrValue.trim();
		return (getListFromAttribute(listAttrName,allowPlural)).contains(tmpTarget);
	}

	public static boolean hasItemInAttrList( Element elem, String listName,
		String target, boolean allowPlural
		)
	{
		String tmpTarget = target.trim();
		return (getListFromAttribute(elem,listName,allowPlural)).contains(tmpTarget);
	}

	public int getAttrListCount( String listName )
	{
		return getAttrListCount( listName, false );
	}

	public static int getAttrListCount( Element elem, String listName )
	{
		return getAttrListCount( elem, listName, false );
	}

	public int getAttrListCount( String listName,
		boolean allowPlural
		)
	{
		return (getListFromAttribute(listName,allowPlural)).size();
	}

	public static int getAttrListCount( Element elem, String listName,
		boolean allowPlural
		)
	{
		return (getListFromAttribute(elem,listName,allowPlural)).size();
	}

	// Add a string to the attribute list
	// It returns true or false depending on whether it really
	// added it or not; it won't add it if it's already there.

	public boolean addStringToAttrList( String listAttrName,
		String newValue
		)
	{
		return addStringToAttrList( listAttrName, newValue, false );
	}

	public static boolean addStringToAttrList( Element elem,
		String listAttrName, String newValue
		)
	{
		return addStringToAttrList( elem, listAttrName, newValue, false );
	}

	public boolean addStringToAttrList( String listAttrName,
		String newValue, boolean allowPlural
		)
	{
		boolean success = addStringToAttrList( myElement,
			listAttrName, newValue, allowPlural
			);

		// The non-static list attribute list methods employ caching
		// so we need to make sure and update caches in all non-static
		// attr list methods

		// If the static version was successful, then we need to clean
		// up the old cache
		if( success )
		{
			// Null out any cache
			if( attrListCache != null )
			{
				if( attrListCache.containsKey(listAttrName) )
					attrListCache.remove(listAttrName);
				// Check the plural form, if applicable
				if( allowPlural )
				{
					String pluralListName = listAttrName + 's';
					if( attrListCache.containsKey(pluralListName) )
						attrListCache.remove(pluralListName);
				}
			}
		}

		return success;
	}

	public static boolean addStringToAttrList( Element elem,
		String listAttrName, String newValue, boolean allowPlural
		)
	{

		if( newValue == null )
			return false;

		String tmpValue = newValue.trim();

		// bail if no value sent, this is not allowed in xml
		if( tmpValue.equals("") )
			return false;

		// bail if this is ALREADY in the list
		if( hasItemInAttrList( elem, listAttrName, tmpValue, allowPlural) )
			return false;

		// Get the string from the attribute
		String tmpAttrStr1 = null;
		String pluralListName = listAttrName + "s";
		tmpAttrStr1 = elem.getAttributeValue( listAttrName );

		// Do we already have a string/list there?
		if( tmpAttrStr1 != null )
		{
			// Replace the old list with a new one, with this
			// value added to the end
			elem.removeAttribute( listAttrName );
			elem.setAttribute( listAttrName,
				tmpAttrStr1 + " " + tmpValue
			);
		}
		// Else we don't already have attribute with this name
		else
		{
			// If we're allowing plural, check that string
			if( allowPlural )
			{
				String tmpAttrStr2 = null;
				tmpAttrStr2 = elem.getAttributeValue( pluralListName );
				// Did we find a plural form?
				if( tmpAttrStr2 != null )
				{
					elem.removeAttribute( pluralListName );
					elem.setAttribute( pluralListName,
						tmpAttrStr2 + " " + tmpValue
						);
				}
				// Else no plural, so add in proper singular form
				else
				{
					elem.setAttribute( listAttrName, tmpValue );
				}
			}
			// Else not allowing plural
			else
			{
				// So just create new singular form
				elem.setAttribute( listAttrName, tmpValue );
			}
		}

		return true;

	}

	/******************************************************************
	 *
	 *		Support for psuedo xpath syntax and simple operations
	 *
	 *******************************************************************/
	private void __sep__Pseudo_XPath_Syntax_Support_ () {}

	public Element findElementByPath( String target )
	{
		return findElementByPath( getJdomElement(), target );
	}

	public static Element findElementByPath( Element sourceElem,
		String target
		)
	{
		// Todo: could add some warnings
		if(debug) System.out.println( "Debug: JDOMHelper.path: Start: given '"+
			target + "'"
			);
		if( target == null )
			return null;
		target = target.trim();

		// Sanity check
		if( target.equals("") )
			return null;

		// Init the return element, this will be
		// "walked" down the tree as we traverse the path
		Element retElem = null;

		if( ! target.substring(0,1).equals("/") )
			// If it does NOT start with a /, then it's
			// relative to the top level node; ie the
			// first part/part2 is a child of root.
			retElem = sourceElem;
		else
			// Else we're starting at "root"
			// Kill the initial slash AND
			// we leave the retELem set to null from
			// above, so it will be handled correctly below.
			target = target.substring(1);

		if(debug) System.out.println( "Debug: JDOMHelper.path: target now ='"+
			target + "'"
			);

		// Keep walking the path until we're done or run out of path
		while( true )
		{
			// sanity check if we're out of path
			if( target.length() < 1 )
				break;

			// Find the next slash
			int nextSlash = target.indexOf('/');

			// Init the current path section
			String pathSection = "";

			// If no slash, just grab the rest
			if( nextSlash < 0 )
			{
				pathSection = target;
				target = "";
			}
			else // else it was >= 0
			{
				// If a slash, then grab the next section and
				// move forward
				if( nextSlash == 0 || nextSlash == target.length()-1 )
					return null;
				pathSection = target.substring( 0, nextSlash );
				target = target.substring( nextSlash+1 );
			}

			pathSection = pathSection.trim();

			// Sanity check, we don't allow /(null)/
			if( pathSection.equals("") )
				break;

			// Look for offset stuff
			// Offsets are ONE based, not zero based, to comply with xpath
			int listIndex = 0;
			int openBracketAt = pathSection.indexOf( '[' );

			// If we found an opening bracket
			if( openBracketAt >= 0 )
			{
				// Look for ending bracket
				int closeBracketAt = pathSection.indexOf( ']',
					openBracketAt
					);
				// Open bracket with no close is bad
				if( closeBracketAt < 0 )
					return null;

				// If there's no characters between the
				// brackets that's bad as well
				if( closeBracketAt == openBracketAt-1 )
					return null;

				String indexString = pathSection.substring(
					openBracketAt+1, closeBracketAt
					);
				indexString = indexString.trim();

				pathSection = pathSection.substring( 0, openBracketAt );
				pathSection = pathSection.trim();

				// Sanity check, can't have []
				if( indexString.equals("") )
					return null;
				// Convert the index to an integer
				try
				{
					listIndex = new Integer(indexString).intValue();
				}
				catch( Exception e )
				{
					// Bail on bad integers
					return null;
				}

				// Sanity check, IF there was an index specified, it
				// must not be zero.  Later on a value of zero will
				// then mean that none was specified.
				if( listIndex == 0 )
					return null;
			}

			if(debug) System.out.println( "Debug: JDOMHelper.path: decoded '"+
				pathSection + "' index=" + listIndex
				);

			// Sanity check
			if( pathSection.equals("") && listIndex == 0 )
				return null;

			// Now we have a path section
			if( retElem != null )
			{
				// If no index, just use the getChild method
				if( listIndex == 0 )
				{
					if( pathSection.equals("") )
					{
						List tmpList = retElem.getChildren();
						if( tmpList.size() < 1 )
							return null;
							retElem = (Element)tmpList.get(0);
					}
					else
						retElem = retElem.getChild( pathSection );
					if( retElem == null )
						break;
				}
				else
				{
					// Else we have an index, get the entire list and
					// do the math

					List children = null;
					if( pathSection.equals("") )
						children = retElem.getChildren();
					else
						children = retElem.getChildren( pathSection );
					int childCount = children.size();
					if( listIndex > 0 )
					{
						// Bounds sanity check
						if( listIndex > childCount )
							return null;

						// grab the element, convert from one based to
						// zero based
						retElem = (Element)children.get( listIndex - 1 );
					}
					else
					{
						// Else it's negative, count from the end
						// Bounds sanity check
						if( childCount + listIndex < 0 )
							return null;

						// Grab the child from the end of the list
						// Since the offset is negative, we ADD it to the
						// # of children to get the index.
						// As a coincidence, this also converts from
						// one based to zero based for us.
						// Example:
						//		3 node list
						//		index of -1, meaning the last/3rd element, offset=2
						//		3 + -1 = 2
						//		index of -3, meaning first element, offset=0
						//		3 + -3 = 0
						retElem = (Element)children.get(
							childCount + listIndex
							);
					}

				}		// end else we do have an index

				// Final sanity check, if we were working with
				// a valid node and now it's null then something is
				// wrong, we don't want to accidently start over
				// back at the root.
				if( retElem == null )
					break;
			}
			else // This is the first node
			{
				// If retElem is null then this is the first time through
				// We are not allowed to specify a index offset
				// for the root
				if( listIndex != 0  )
					break;		// returns the null value we found before

				// Verify that the names match
				if( sourceElem.getName().equals(pathSection) )
					retElem = sourceElem;
				else		// Error, should match top node
					break;		// returns the null value we found before
			}

		}		// End of while loop

		return retElem;
	}






	public static Element findElementByPath( Element inStartElem,
		List inPathBits, boolean inCreateOK, Element inRootElem
		)
	{
		// if(debug) System.out.println( "Debug: JDOMHelper.path:" );

		if( inStartElem == null || inPathBits == null )
		{
			System.err.println( "ERROR: JDOMHelper:findElmentByPath(new1):"
				+ " Null arguments passed in."
				+ " inStartElem=" + inStartElem
				+ " inPathBits=" + inPathBits
				);
			return null;
		}

		if( inPathBits.size() < 1 )
			return inStartElem;

		// Handle the special "/" case
		boolean isRooted = false;
		String firstBit = (String)inPathBits.get(0);
		Element currElem = inStartElem;
		if( firstBit.equals("/") )
		{
			// Note that we're rooted and update the path bits list
			isRooted = true;
			inPathBits.remove( 0 );
			// Figure out what to use for root
			// Did they specifically tell us what to use?
			if( inRootElem != null )
				currElem = inRootElem;
			// Else we'll figure it out for ourselves
			else
			{
				// If start element is already a root, use it!
				if( inStartElem.isRootElement() )
					currElem = inStartElem;
				// Else find the main doc, and then take it's root element
				else
				{
					// Get the doc and check it
					Document parentDoc = inStartElem.getDocument();
					if( parentDoc != null )
					{
						Element rootElem = parentDoc.getRootElement();
						if( rootElem != null )
							currElem = rootElem;
						// Else the root element of the doc was null
						else
						{
							System.err.println( "Waring: JDOMHelper:findElmentByPath(new1):"
								+ " Unable to get main doc's root element for root directive."
								+ " You may want to pass in a root element."
								+ " Will use start element as root element."
								+ " inStartElem=" + inStartElem
								+ " inPathBits=" + inPathBits
								);
							currElem = inStartElem;
						}
					}
					// Else the main doc we found was null
					else
					{
						System.err.println( "Waring: JDOMHelper:findElmentByPath(new1):"
							+ " Unable to get main doc for root directive."
							+ " You may want to pass in a root element."
							+ " Will use start element as root element."
							+ " inStartElem=" + inStartElem
							+ " inPathBits=" + inPathBits
							);
						currElem = inStartElem;
					}
				}

			}   // End else we will figure out where root is
		}   // End if first element is root

		// We may have cleaned out the path bits list, check again
		if( inPathBits.size() < 1 )
			return currElem;

		// Keep walking the path until we're done or run out of path
		for( Iterator it = inPathBits.iterator(); it.hasNext() ; )
		{
			String pathBit = (String)it.next();

			// Sanity check, this should never happen (famous last words)
			// If it does, check the path chopper methods.
			if( pathBit.trim().equals("") )
			{
				System.err.println( "ERROR: JDOMHelper:findElmentByPath(new1):"
					+ " Null sub path found?"
					);
				return null;
			}
			if( pathBit.equals("..") )
			{
				System.err.println( "ERROR: JDOMHelper:findElmentByPath(new1):"
					+ " Dot-dot syntax not yet supported."
					);
				return null;
			}
			if( pathBit.equals(".") )
			{
				isRooted = false;
				continue;
			}
			// This is probably extremely rare.
			// The first / is taken care of.
			// The path chopper should only create it at the start or end
			// And most callers will have skimmed off any ending /
			if( pathBit.equals("/") )
			{
				if( it.hasNext() )
				{
					System.err.println( "ERROR: JDOMHelper:findElmentByPath(new1):"
						+ " A bare '/' can only be the first or last part of a path."
						);
					return null;
				}
				// Else it's OK, we're done
				break;
			}

			// If we're rooted, then the current node should match
			// this element
			if( isRooted )
			{
				String elemName = currElem.getName();
				if( pathBit.equals(elemName) )
				{
					// OK, turn this off and continue
					isRooted = false;
					// Element stays the same
					continue;
				}
				// Else it does NOT match, this is bad
				{
					System.err.println( "ERROR: JDOMHelper:findElmentByPath(new1):"
						+ " A root path of the form /name did not match the name of the root element."
						+ ", /name=" + pathBit
						+ ", root/current elment name = " + elemName
						+ " Depending on what you're trying to do, you may just want to drop the leading /;"
						+ " we would then look for the name in the CHILDREN of the root node."
						+ " You can also use /./name to refer to a CHILD of the ROOT."
						+ " '/' by itself returns the designated root."
						);
					return null;
				}
			}

			// Get the next element in the chain
			// If it doesn't like something it will complain and we'll
			// just get back a null
			currElem = findChildByPathBit( currElem, pathBit, inCreateOK );

			if( currElem == null )
				break;

		}   // End for each element in path

		// Return the answer
		return currElem;

	}

	// Will return NULL if empty string
	private static String extractChildNameFromPathBit( String inPathBit )
	{
		if( inPathBit == null )
		{
			System.err.println( "ERROR: JDOMHelper:extractChildNameFromPathBit:"
				+ " NULL path passed in, returning null."
				);
			return null;
		}
		String outPathBit = inPathBit;
		int leftBracketAt = outPathBit.indexOf( '[' );
		if( leftBracketAt >= 0 )
		{
			if( leftBracketAt == 0 )
				outPathBit = "";
			else
				outPathBit = outPathBit.substring( 0, leftBracketAt );
		}
		outPathBit = outPathBit.trim();
		if( outPathBit.equals("") )
			outPathBit = null;
		return outPathBit;
	}
	private static int extractRawOffsetFromPathBit( String inPathBit )
	{
		if( inPathBit == null )
		{
			System.err.println( "ERROR: JDOMHelper:extractRawOffsetFromPathBit:"
				+ " NULL path passed in, returning zero."
				);
			return 0;
		}
		// Look for offset stuff
		// Offsets are ONE based, not zero based, to comply with xpath
		int outIndex = 0;
		int openBracketAt = inPathBit.indexOf( '[' );

		// If we found an opening bracket
		if( openBracketAt >= 0 )
		{
			// Look for ending bracket
			int closeBracketAt = inPathBit.indexOf( ']',
				openBracketAt
				);
			// Open bracket with no close is bad
			if( closeBracketAt < 0 )
			{
				System.err.println( "ERROR: JDOMHelper:extractRawOffsetFromPathBit:"
					+ " Unbalanced square brackets, returning zero."
					+ " string='" + inPathBit + "'"
					);
				return 0;
			}

			// If there's no characters between the
			// brackets that's bad as well
			if( closeBracketAt == openBracketAt-1 )
			{
				System.err.println( "ERROR: JDOMHelper:extractRawOffsetFromPathBit:"
					+ " Nothing in between square brackets, returning zero."
					+ " string='" + inPathBit + "'"
					);
				return 0;
			}

			String indexString = inPathBit.substring(
				openBracketAt+1, closeBracketAt
				);
			indexString = indexString.trim();

			// Sanity check, can't have []
			if( indexString.equals("") )
			{
				System.err.println( "ERROR: JDOMHelper:extractRawOffsetFromPathBit:"
					+ " Only whitespace in between square brackets, returning zero."
					+ " string='" + inPathBit + "'"
					);
				return 0;
			}

			// Convert the index to an integer
			try
			{
				outIndex = Integer.parseInt( indexString );
			}
			catch( Exception e )
			{
				// Bail on bad integers
				System.err.println( "ERROR: JDOMHelper:extractRawOffsetFromPathBit:"
					+ " Error parsing integer in square brackets, returning zero."
					+ " int string='" + indexString + "'"
					+ " path segment it was in='" + inPathBit + "'"
					);
				return 0;
			}

		}   // End if there was a left bracket

		return outIndex;
	}

	// Follow a path one level
	// We do NOT handle / or . or .. of any kind
	// AND we do NOT check for such nonsense
	// This is usually called by a method that's already checking that
	private static Element findChildByPathBit( Element inStartElem,
		String inPathBit, boolean inCreateOK
		)
	{
		if( inStartElem == null || inPathBit == null )
		{
			System.err.println( "ERROR: JDOMHelper:findChildByPathBit:"
				+ " NULL input(s)."
				+ " Returning NULL."
				+ " start element=" + inStartElem
				+ " path=" + inPathBit
				);
			return null;
		}

		String childName = extractChildNameFromPathBit( inPathBit );
		int rawOrdinal = extractRawOffsetFromPathBit( inPathBit );

		Element outElem = null;

		// Sanity check
		if( childName == null && rawOrdinal == 0 )
		{
			System.err.println( "ERROR: JDOMHelper:findChildByPathBit:"
				+ " Input path segment has no name and no/zero offset."
				+ " Returning NULL."
				+ " path='" + inPathBit + "'"
				);
			return null;
		}

		// If no index, just use the getChild method
		if( rawOrdinal == 0 )
		{
			outElem = inStartElem.getChild( childName );
			// If we didn't find anything and we're told it's OK to
			// create, then go ahead and create it
			if( outElem == null && inCreateOK )
			{
				Element tmpElem = new Element( childName );
				// If we were able to create it, go ahead and attach it
				if( tmpElem != null )
				{
					tmpElem.detach();
					inStartElem.addContent( tmpElem );
					outElem = tmpElem;
				}
				else
				{
					System.err.println( "ERROR: JDOMHelper:findChildByPathBit:"
						+ " Unable to find path, AND unable to create it as requested."
						+ " Returning NULL."
						+ " attempted element='" + childName + "'"
						+ " full path='" + inPathBit + "'"
						);
					return null;
				}
			}
		}
		// Else we have an index, get the entire list and
		// do the math
		else
		{
			List children = null;
			// Get the full list
			if( childName == null )
				children = inStartElem.getChildren();
			// Or just the children with that name
			else
				children = inStartElem.getChildren( childName );

			int childCount = children.size();

			// If it's a positive index
			if( rawOrdinal > 0 )
			{
				// Bounds sanity check
				if( rawOrdinal > childCount )
				{
					System.err.print( "ERROR: JDOMHelper:findChildByPathBit:"
						+ " Index out of range."
						+ " Returning NULL."
						+ " requested index='" + rawOrdinal
						);
					if( childCount > 0 )
						System.err.print(
							" Number of matching children='" + childCount
							);
					else
						System.err.print( " There are no matching children." );
					if( childName != null )
						System.err.print( " child name='" + childName + "'" );
					if( inCreateOK )
						System.err.print( " And cannot create children with an index/offset." );
					System.err.println();
					return null;
				}
				// grab the element, convert from one based to
				// zero based
				outElem = (Element)children.get( rawOrdinal - 1 );
			}
			// Else it's negative, count from the end
			// Bounds sanity check
			else
			{
				if( childCount + rawOrdinal < 0 )
				{
					System.err.print( "ERROR: JDOMHelper:findChildByPathBit:"
						+ " Index out of range."
						+ " Returning NULL."
						+ " requested index='" + rawOrdinal
						+ " number of matching children='" + childCount
						);
					if( childCount > 0 )
						System.err.print(
							" Max negative offset must not be greater than number children (abs)."
							+ " Most negative allowable offset would be"
							+ ( -1 * childCount )
							);
					else
						System.err.print( " There are no matching children." );
					if( childName != null )
						System.err.print( " child name='" + childName + "'" );
					if( inCreateOK )
						System.err.print( " And cannot create children with an index/offset." );
					System.err.println();
					return null;
				}

				// Grab the child from the end of the list
				// Since the offset is negative, we ADD it to the
				// # of children to get the index.
				// As a coincidence, this also converts from
				// one based to zero based for us.
				// Example:
				//		3 node list
				//		index of -1, meaning the last/3rd element, offset=2
				//		3 + -1 = 2
				//		index of -3, meaning first element, offset=0
				//		3 + -3 = 0
				outElem = (Element)children.get(
					childCount + rawOrdinal
					);
			}   // End else it's a negative index/offset

		}		// end else we do have an index

		return outElem;
	}

	// Return multiple elements from a path query
	// We do NOT allow for "/foo" queries here.
	// And we do not allow for offsets in the final part
	// of the path.
	public List findElementsByPath( String target )
	{
		return findElementsByPath( getJdomElement(), target );
	}
	public static List findElementsByPath( Element sourceElem,
		String target
		)
	{
		List retList = new Vector();
		if( sourceElem == null || target == null )
			return retList;

		// Chop up the string into the lead and last part
		int lastSlashAt = target.lastIndexOf( '/' );

		// Sanity check, and we do NOT allow "/foo" in this method
		if( lastSlashAt == 0 || lastSlashAt == target.length()-1 )
			return retList;

		// The two parts of the path
		String partA = null;
		String partB = null;

		// Do we have a leading part?
		if( lastSlashAt > 0 )
		{
			partA = target.substring( 0, lastSlashAt );
			partB = target.substring( lastSlashAt+1 );
		}
		else		// Else just the second half of the path
		{
			partA = "";
			partB = target;
		}

		// Sanity check
		if( partB.indexOf('[') >= 0 || partB.indexOf(']') >= 0 )
			return retList;
		partB = partB.trim();
		if( partB.equals("") )
			return retList;

		// Figure out what the parent is
		Element parent = null;

		// If there's any partA path, look it up
		if( ! partA.trim().equals("") )
			parent = findElementByPath( sourceElem, partA );
		else
			parent = sourceElem;

		// Sanity check
		if( parent == null )
			return retList;

		// Have jdom do the rest
		return parent.getChildren( partB );

	}


	// Given a path, return text
	// We will return a NULL if we don't find the element
	// you asked for.
	// We do not trim it for you
	public String getTextByPath( String path )
	{
		return getTextByPath( getJdomElement(), path );
	}
	public static String getTextByPath( Element startElem,
		String path
		)
	{
		Element tmpElem = findElementByPath( startElem, path );
		if( tmpElem == null )
			return null;
		return tmpElem.getText();
	}

	public String getTextByPathTrimOrNull( String path )
	{
		return getTextByPathTrimOrNull( getJdomElement(), path );
	}
	public static String getTextByPathTrimOrNull( Element startElem,
		String path
		)
	{
		Element tmpElem = findElementByPath( startElem, path );
		if( tmpElem == null )
			return null;
		String tmpStr = tmpElem.getText();
		tmpStr = NIEUtil.trimmedStringOrNull( tmpStr );
		return tmpStr;
	}

	// These also call Element's "normalize" to clean up
	// bounded white space within the string, changing that to a single space
	public String getTextByPathSuperTrimOrNull( String path )
	{
		return getTextByPathSuperTrimOrNull( getJdomElement(), path );
	}
	public static String getTextByPathSuperTrimOrNull( Element startElem,
		String path
		)
	{
		Element tmpElem = findElementByPath( startElem, path );
		if( tmpElem == null )
			return null;
		String tmpStr = tmpElem.getTextNormalize();
		tmpStr = NIEUtil.trimmedStringOrNull( tmpStr );
		return tmpStr;
	}




	// Convenience function
	// Find all the elements that match a path, grab the text of
	// those elements and shove it into a vector
	// WILL ALWAYES RETURN A LIST, but maybe with 0 strings
	// If we get back a NULL element we will not include that element
	// However, if the element's getText returns null we WILL put in a ""
	// string, so all filled slots will have strings from nodes that were
	// actually found.
	// We do NOT trim the strings, so if you care, you should do it
	// or use the other method
	public List getTextListByPath( String inPath )
	{
		return getTextListByPath( getJdomElement(), inPath );
	}
	public static List getTextListByPath(
		Element inStartingElem, String inPath
		)
	{
		// Prime the return value
		List retList = new Vector();

		// Find the matching children
		List elements = findElementsByPath( inStartingElem, inPath );
		// Sanity check, should never happen
		if( elements == null )
			return retList;

		// Loop through all the matches
		Iterator it = elements.iterator();
		// For each field in the record
		while( it.hasNext() )
		{
			// pull the next element
			Element tmpElem = (Element)it.next();
			if( tmpElem == null )
				continue;       // This will likely never happen
			String tmpContent = tmpElem.getText();
			if( tmpContent == null )
				tmpContent = "";       // This should never happen
			retList.add( tmpContent );
		}

		return retList;
	}

	// Similar to above, but will DO trim and do NOT include null or empty
	// items
	public List getTextListByPathNotNullTrim( String inPath )
	{
		return getTextListByPathNotNullTrim( getJdomElement(), inPath );
	}
	// ALWAYS RETURN A LIST, even if zero elements
	public static List getTextListByPathNotNullTrim(
		Element inStartingElem, String inPath
		)
	{
		// Prime the return value
		List retList = new Vector();

		// Find the matching children
		List elements = findElementsByPath( inStartingElem, inPath );
		// Sanity check, should never happen
		if( elements == null )
			return retList;

		// Loop through all the matches
		Iterator it = elements.iterator();
		// For each field in the record
		while( it.hasNext() )
		{
			// pull the next element
			Element tmpElem = (Element)it.next();
			if( tmpElem == null )
				continue;       // This will likely never happen
			String tmpContent = tmpElem.getText();
			if( tmpContent == null )
				continue;       // This should never happen
			// Trim and skip if null
			tmpContent = tmpContent.trim();
			if( tmpContent.equals("") )
				continue;
			retList.add( tmpContent );
		}

		return retList;
	}

	// Similar to above, but we also normalize internal spaces
	public List getTextListByPathNotNullSuperTrim( String inPath )
	{
		return getTextListByPathNotNullSuperTrim( getJdomElement(), inPath );
	}
	// ALWAYS RETURN A LIST, even if zero elements
	public static List getTextListByPathNotNullSuperTrim(
		Element inStartingElem, String inPath
		)
	{
		// Prime the return value
		List retList = new Vector();

		// Find the matching children
		List elements = findElementsByPath( inStartingElem, inPath );
		// Sanity check, should never happen
		if( elements == null )
			return retList;

		// Loop through all the matches
		Iterator it = elements.iterator();
		// For each field in the record
		while( it.hasNext() )
		{
			// pull the next element
			Element tmpElem = (Element)it.next();
			if( tmpElem == null )
				continue;       // This will likely never happen
			String tmpContent = tmpElem.getTextNormalize();
			if( tmpContent == null )
				continue;       // This should never happen
			// Trim and skip if null
			tmpContent = tmpContent.trim();
			if( tmpContent.equals("") )
				continue;
			retList.add( tmpContent );
		}

		return retList;
	}


	// Complex Query
	// Variant 1: Given a starting path, an element name,
	// an attribute name and value, and a direction to search,
	// find the matching node
	// If the starting path is null that's OK, we will scan
	// from the initial element
	// If the elementName is null that's OK, we will scan
	// all the children at that point.

	public Element mixedQuery( String startPath,
		String optionalElementName, String attributeName,
		String attributeValue, boolean searchBackwardsFlag
		)
	{
		return mixedQuery( getJdomElement(), startPath,
			optionalElementName, attributeName, attributeValue,
			searchBackwardsFlag
			);
	}

	public Element mixedQuery( String startPath,
		String optionalElementName, String attributeName,
		String attributeValue
		)
	{
		return mixedQuery( getJdomElement(), startPath,
			optionalElementName, attributeName, attributeValue,
			false
			);
	}

	public static Element mixedQuery( Element sourceElem, String startPath,
		String optionalElementName, String attributeName, String attributeValue
		)
	{
		return mixedQuery( sourceElem, startPath,
			optionalElementName, attributeName, attributeValue,
			false
			);
	}

	public static Element mixedQuery( Element sourceElem, String startPath,
		String optionalElementName, String attributeName, String attributeValue,
		boolean searchBackwardsFlag
		)
	{

		// First find the parent
		Element parent = null;
		if( startPath != null )
		{
			parent = findElementByPath( sourceElem, startPath );
			if( parent == null )
				return null;
		}
		else
			parent = sourceElem;

		// Now get the matching children
		List children = null;

		if( optionalElementName != null )
			children = parent.getChildren( optionalElementName );  // Get named children
		else
			children = parent.getChildren();                       // Get all children

		// The eventual answer
		Element returnElem = null;

		// If we're searching forward
		if( ! searchBackwardsFlag )
		{
			for( int i=0; i<children.size(); i++ )
			{
				Element tmpElem = (Element)children.get(i);
				String tmpAttrValue = tmpElem.getAttributeValue( attributeName );
				if( tmpAttrValue == null )
					continue;

				if( tmpAttrValue.equals(attributeValue) )
				{
					returnElem = tmpElem;
					break;
				}
			}
		}
		else		// Yes we are searching backwards
		{
			for( int i = children.size()-1; i >= 0; i-- )
			{
				Element tmpElem = (Element)children.get(i);
				String tmpAttrValue = tmpElem.getAttributeValue( attributeName );
				if( tmpAttrValue == null )
					continue;
				if( tmpAttrValue.equals(attributeValue) )
				{
					returnElem = tmpElem;
					break;
				}
			}
		}

		// We've either found it we haven't
		return returnElem;

	}



	// Complex Query
	// Variant 2: Given a starting path, an element name,
	// an attribute name and value, and a direction to search,
	// find ALL matching Elements.
	// If the elementName is null that's OK, we will scan
	// all the children at that point.

	public List mixedListQuery( String startPath,
		String optionalElementName, String attributeName, String attributeValue,
		boolean searchBackwardsFlag
		)
	{
		return mixedListQuery( getJdomElement(), startPath,
			optionalElementName, attributeName, attributeValue,
			searchBackwardsFlag
			);
	}

	public static List mixedListQuery( Element sourceElem, String startPath,
		String optionalElementName, String attributeName, String attributeValue,
		boolean searchBackwardsFlag
		)
	{
		List retList = new Vector();

		// First find the parent
		Element parent = findElementByPath( sourceElem, startPath );
		if( parent == null )
			return retList;

		// Now get the matching children
		List children = null;

		if( optionalElementName != null )
			// Get named children
			children = parent.getChildren( optionalElementName );
		else
			// Get all children
			children = parent.getChildren();

		// If we're searching forward
		if( ! searchBackwardsFlag )
		{
			for( int i=0; i<children.size(); i++ )
			{
				Element tmpElem = (Element)children.get(i);
				String tmpAttrValue = tmpElem.getAttributeValue( attributeName );
				if( tmpAttrValue == null )
					continue;
				if( tmpAttrValue.equals(attributeValue) )
					retList.add( tmpElem );
			}
		}
		else		// Yes we are searching backwards
		{
			for( int i = children.size()-1; i >= 0; i-- )
			{
				Element tmpElem = (Element)children.get(i);
				String tmpAttrValue = tmpElem.getAttributeValue( attributeName );
				if( tmpAttrValue == null )
					continue;

				if( tmpAttrValue.equals(attributeValue) )
					retList.add( tmpElem );
			}
		}

		// we always return a valid list, maybe with 0 elements
		return retList;

	}


	// Similar to getAttributeValue and getString functions, will
	// return the text of a named attribute given a path and
	// an attribute name.
	// Returns NULL if there is no such attribute
	public String getTextFromSinglePathAttr( String inPath, String inAttrName )
	{
		return getTextFromSinglePathAttr( getJdomElement(), inPath, inAttrName );
	}
	public static String getTextFromSinglePathAttr( Element inStartElem, String inPath,
		String inAttrName
		)
	{
		if( inStartElem == null || inAttrName == null ||
			inAttrName.trim().equals("")
			)
			return null;
			// Todo: complain loudly?

		// First find the parent
		Element theElem = findElementByPath( inStartElem, inPath );
		if( theElem == null )
			return null;

		// Have jdom do the rest
		return theElem.getAttributeValue( inAttrName );
	}


	// Get an int, default of zero
	public int getIntFromPathText(
		String inPath
		)
	{
		return getIntFromPathText(
			getJdomElement(), inPath, 0
			);
	}
	public static int getIntFromPathText(
		Element inStartElem, String inPath
		)
	{
		return getIntFromPathText(
			inStartElem, inPath, 0
			);
	}
	// Return a default value if not found
	public int getIntFromPathText(
		String inPath, int defaultValue
		)
	{
		return getIntFromPathText(
			getJdomElement(), inPath, defaultValue
			);
	}
	public static int getIntFromPathText(
		Element inStartElem, String inPath,
		int defaultValue
		)
	{
		// First find the parent
		String pathText = getTextByPath( inStartElem, inPath );
		if( pathText == null || pathText.trim().equals("") )
			return defaultValue;
		pathText = pathText.trim();

		int theValue = defaultValue;
		try
		{
			theValue = Integer.parseInt( pathText );
		}
		catch(Exception e)
		{
			System.err.println( "Jdh: error parsing Int string '" +
				pathText + "', returning default value '" + defaultValue + "'"
				);
			theValue = defaultValue;
		}

		return theValue;
	}

	// Get a long, default of zero
	public long getLongFromPathText(
		String inPath
		)
	{
		return getLongFromPathText(
			getJdomElement(), inPath, 0L
			);
	}
	public static long getLongFromPathText(
		Element inStartElem, String inPath
		)
	{
		return getLongFromPathText(
			inStartElem, inPath, 0L
			);
	}
	// Return a default value if not found
	public long getIntFromPathText(
		String inPath, long defaultValue
		)
	{
		return getLongFromPathText(
			getJdomElement(), inPath, defaultValue
			);
	}
	public static long getLongFromPathText(
		Element inStartElem, String inPath,
		long defaultValue
		)
	{
		// First find the parent
		String pathText = getTextByPath( inStartElem, inPath );
		if( pathText == null || pathText.trim().equals("") )
			return defaultValue;
		pathText = pathText.trim();

		long theValue = defaultValue;
		try
		{
			theValue = Long.parseLong( pathText );
		}
		catch(Exception e)
		{
			System.err.println( "Jdh: error parsing Long int string '" +
				pathText + "', returning default value '" + defaultValue + "'"
				);
			theValue = defaultValue;
		}

		return theValue;
	}



	// Get a Boolean, default of false
	public boolean getBooleanFromPathText(
		String inPath
		)
	{
		return getBooleanFromPathText(
			getJdomElement(), inPath, false
			);
	}
	public static boolean getBooleanFromPathText(
		Element inStartElem, String inPath
		)
	{
		return getBooleanFromPathText(
			inStartElem, inPath, false
			);
	}
	// Return a default value if not found
	public boolean getBooleanFromPathText(
		String inPath, boolean defaultValue
		)
	{
		return getBooleanFromPathText(
			getJdomElement(), inPath, defaultValue
			);
	}
	public static boolean getBooleanFromPathText(
		Element inStartElem, String inPath,
		boolean defaultValue
		)
	{
		// First find the parent
		String pathText = getTextByPath( inStartElem, inPath );

		// Have jdom helper do the rest
		return decodeBooleanString( pathText, defaultValue );
	}

	// Similar to getBooleanFromAttribute, except that
	// this accpepts a path

	// Return false if not found
	public boolean getBooleanFromSinglePathAttr(
		String inPath, String inAttrName
		)
	{
		return getBooleanFromSinglePathAttr(
			getJdomElement(), inPath, inAttrName, false
			);
	}
	public static boolean getBooleanFromSinglePathAttr(
		Element inStartElem, String inPath, String inAttrName
		)
	{
		return getBooleanFromSinglePathAttr(
			inStartElem, inPath, inAttrName, false
			);
	}
	// Return a default value if not found
	public boolean getBooleanFromSinglePathAttr(
		String inPath, String inAttrName, boolean defaultValue
		)
	{
		return getBooleanFromSinglePathAttr(
			getJdomElement(), inPath, inAttrName, defaultValue
			);
	}
	public static boolean getBooleanFromSinglePathAttr(
		Element inStartElem, String inPath,
		String inAttrName, boolean defaultValue
		)
	{
		// First find the parent
		Element theElem = findElementByPath( inStartElem, inPath );
		if( theElem == null )
			return defaultValue;

		// Have jdom helper do the rest
		return getBooleanFromAttribute( theElem, inAttrName, defaultValue );
	}

	// Return a default value if not found
	public int getIntFromSinglePathAttr(
		String inPath, String inAttrName, int defaultValue
		)
	{
		return getIntFromSinglePathAttr(
			getJdomElement(), inPath, inAttrName, defaultValue
			);
	}
	public static int getIntFromSinglePathAttr(
		Element inStartElem, String inPath,
		String inAttrName, int defaultValue
		)
	{
		// First find the parent
		Element theElem = findElementByPath( inStartElem, inPath );
		if( theElem == null )
			return defaultValue;

		// Have jdom helper do the rest
		return getIntFromAttribute( theElem, inAttrName, defaultValue );
	}


	// Given a path and the name of an attribute, return the attribute's
	// contents as a list (white space separated lists are stored in attrs)
	// If you're doing this on the TOP level element
	// just use getListFromAttribute
	// Currently no plural form
	// Currently no form that sweeps for all elements
	public List getAttrValuesListFromSingularPath( String path,
		String listAttrName
		)
	{
		Element attrElem = findElementByPath( path );
		// Bail if we didn't find anything
		if( attrElem == null )
			return new Vector();
		return getListFromAttribute( attrElem, listAttrName );
	}

	// The static version, works on any element
	public static List getAttrValuesListFromSingularPath( Element startingElem,
		String path, String listAttrName
		)
	{
		if( startingElem == null )
			return new Vector();
		Element attrElem = findElementByPath( startingElem, path );
		// Bail if we didn't find anything
		if( attrElem == null )
			return new Vector();
		return getListFromAttribute( attrElem, listAttrName );
	}


	// Similar to getListFromAttribute
	// Given a jdom path and an attribute name, give back
	// a list of strings, from the content of that attribute
	// Will always return a list, even if no elements found,
	// so just need to check .size()
	// In this version we do NOT normalize to lower case and
	// we DO allow duplicates (vs. our getListFromAttrribute method)
	public List getListFromSinglePathAttr( String inPath, String inAttrName )
	{
		return getListFromSinglePathAttr( getJdomElement(), inPath, inAttrName );
	}
	public static List getListFromSinglePathAttr( Element inStartElem, String inPath,
		String inAttrName
		)
	{

		// The return list, we always return something
		List retList = new Vector();

		// Get the text, given the path and attribute name
		String attrStr = getTextFromSinglePathAttr( inStartElem,
			inPath, inAttrName
			);
		// Bail if failed or null string
		if( attrStr == null || attrStr.trim().equals("") )
			return retList;

		// Now prepare to loop through the string
		StringTokenizer st = new StringTokenizer( attrStr );
		while( st.hasMoreTokens() )
		{
			String item = st.nextToken();
			// Trim and make sure there's something really there
			item = item.trim();     // no .toLowerCase()
			if( ! item.equals("") )
			{
				// if( ! retList.contains(item) )
				retList.add(item);
			}
		}

		return retList;

	}

	// Add an element as the new last child of a node
	// Return the child that was added, or null if it failed
	public Element addElementToPath( String target, Element newChild )
	{
			return addElementToPath( getJdomElement(), target, newChild );
	}
	public static Element addElementToPath( Element sourceElem,
		String target, Element newChild
		)
	{
		// If the path is null, just add it to the starting node
		// Not useful as a direct call here, but helps support the
		// addXMLTextToPath which in turn calls this method
		Element parent = null;
		if( target == null || target.trim().equals("") )
			parent = sourceElem;
		else
		{
			// Find the node we're to remove
			parent = findElementByPath( sourceElem, target );
			if( parent == null )
				return null;
		}

		// To be safe, try and remove the child from any possible
		// old parent
		newChild.detach();

		// Tell the parent to add the child
		try
		{
			parent.addContent( newChild );
		}
		catch (Exception e)
		{
			System.err.println( "Error: JDH:addElementToPath: parent.addContent()" +
				" threw an exception: " + e
				);
			return null;
		}

		return newChild;
	}
	public Element addElementToPath( String target, JDOMHelper newChild )
	{
			return addElementToPath( getJdomElement(), target, newChild );
	}
	public static Element addElementToPath( Element sourceElem,
		String target, JDOMHelper newChild
		)
	{
		// If the path is null, just add it to the starting node
		// Not useful as a direct call here, but helps support the
		// addXMLTextToPath which in turn calls this method
		Element parent = null;
		if( target == null || target.trim().equals("") )
			parent = sourceElem;
		else
		{
			// Find the node we're to remove
			parent = findElementByPath( sourceElem, target );
			if( parent == null )
				return null;
		}

		// To be safe, try and remove the child from any possible
		// old parent
		Element lNewChild = newChild.getJdomElement();
		lNewChild.detach();

		// Tell the parent to add the child
		try
		{
			parent.addContent( lNewChild );
		}
		catch (Exception e)
		{
			System.err.println( "Error: JDH:addElementToPath: parent.addContent()" +
				" threw an exception: " + e
				);
			return null;
		}

		return lNewChild;
	}

	public Element addXMLTextToPath( String path, String xmlText )
	{
		return addXMLTextToPath( getJdomElement(), path, xmlText );
	}
	public static Element addXMLTextToPath( Element sourceElem,
		String path, String xmlText
		)
	{

		// Turn the XML Text into an element
		JDOMHelper newJH = null;
		try
		{
			newJH = new JDOMHelper( xmlText, null );
		}
		catch (Exception e)
		{
			return null;
		}

		// Grab the top element from it
		Element newElem = newJH.getJdomElement();

		// Now just call the normal, static add element method
		return addElementToPath( sourceElem, path, newElem );

	}

	// This will always return a list
	// nulls/empty are OK
	public static List fullPathChopper( String inPath )
	{

		List outList = new Vector();
		if( inPath == null || inPath.trim().equals("") )
		{
			if( inPath == null )
				System.err.println( "ERROR:JDOMHelper:fullPathChopper:"
					+ " Was passed in a NULL path."
					);
			return outList;
		}

		inPath = inPath.trim();

		// Whine about // query directive, unsupported
		if( inPath.length()>=2 && inPath.startsWith( "//" ) )
		{
			System.err.println( "ERROR:JDOMHelper:fullPathChopper:"
				+ " Path starts with '//' query directive"
				+ " which is not supported at this time."
				+ " path='" + inPath + "'"
				);
			return outList;
		}

		// Handle "root" directive
		if( inPath.startsWith( "/" ) )
		{
			outList.add( "/" );
			if( inPath.length() > 1 )
				inPath = inPath.substring( 1 );
			else
				inPath = "";
		}

		if( inPath.equals("") )
			return outList;

		StringTokenizer st = new StringTokenizer( inPath, "/" );
		while( st.hasMoreTokens() )
		{
			String item = st.nextToken();
			item = item.trim();
			// If we got a valid sub path, add it!
			if( ! item.equals("") )
				outList.add( item );
			// Else it was null
			else
			{
				// Paths are allowed to have a trailing slash
				// If so, add it
				if( ! st.hasMoreTokens() )
					outList.add( "/" );
				// Otherwise this is clearly invalid
				else
				{
					System.err.println( "ERROR:JDOMHelper:fullPathChopper:"
						+ " Path has null subpath."
						+ " path='" + inPath + "'"
						);
					// Null out the list
					outList = new Vector();
					break;
				}
			}
		}

		return outList;
	}

	// See if we have a normal looking, plane old path element
	// So it's not null and does NOT have [], / @ or spaces in it
	public static boolean getIsPathBitAPlainElementName( String pathBit )
	{
		if( pathBit == null )
			return false;
		pathBit = pathBit.trim();
		if( pathBit.equals("") )
			return false;
		if(
				pathBit.indexOf('[') >= 0
				|| pathBit.indexOf(']') >= 0
				|| pathBit.indexOf('/') >= 0
				|| pathBit.indexOf('@') >= 0
				|| pathBit.indexOf('.') >= 0
				|| pathBit.indexOf(' ') >= 0
				|| pathBit.indexOf('\t') >= 0
				|| pathBit.indexOf(',') >= 0
			)
		{
			return false;
		}

		return true;
	}

	// Given a path, create a NEW element with that path and add the
	// text as content
	public Element addSimpleTextToNewPath( String path, String simpleText )
	{
		return addSimpleTextToNewPath( getJdomElement(), path, simpleText );
	}
	public static Element addSimpleTextToNewPath( Element inSourceElem,
		String inPath, String inNewText
		)
	{

		if( inSourceElem == null || inPath==null || inNewText==null )
		{
			System.err.println( "Error: JDOMHelper:addSimpleTextToNewPath:"
				+ " null value(s) passed in"
				+ ", inSourceElem=" + inSourceElem
				+ ", inPath=" + inPath
				+ ", inNewText=" + inNewText
				);
			return null;
		}

		int textLen = inNewText.length();

		List choppedPath = fullPathChopper( inPath );
		int pathLen = choppedPath.size();

		if( pathLen < 1 )
		{
			System.err.println( "Error: JDOMHelper:addSimpleTextToNewPath:"
				+ " Path too short; must have at least one element."
				+ ", inPath=" + inPath
				);
			return null;
		}

		// The last part of the path is the element we will create
		String lastPathBit = (String)choppedPath.get( pathLen - 1 );
		// And the rest is where we'll go
		choppedPath.remove( pathLen - 1 );

		// Some checking
		if( lastPathBit.equals("/") )
		{
			System.err.println( "Error: JDOMHelper:addSimpleTextToNewPath:"
				+ " Path must not end in '/'; not supported in this method."
				+ ", inPath=" + inPath
				);
			return null;
		}
		if( ! getIsPathBitAPlainElementName( lastPathBit ) )
		{
			System.err.println( "Error: JDOMHelper:addSimpleTextToNewPath:"
				+ " Last element in path must be simple element name."
				+ ", inPath=" + inPath
				+ ", lastPathBit=" + lastPathBit
				);
			return null;
		}

		// Lookup direct parent with list based lookup
		// Creating is OK
		// Currently we're not passing in an alternative root
		Element directParent = findElementByPath( inSourceElem,
			choppedPath, true, null
			);

		// If null, complain, because we said creating was OK
		if( directParent == null )
		{
			System.err.println( "ERROR: JDOMHelper:addSimpleTextToNewPath:"
				+ " Unable to create intermediate path."
				+ ", inPath=" + inPath
				);
			return null;
		}

		// Create the element itself
		Element newChild = new Element( lastPathBit );
		newChild.detach();

		// add the content

		//newChild.addContent( inNewText );
		// ^^^ need to handle long strings as cdata

		// WARNING: We're setting this here
		// Later we'll make it an argument you pass in
		// Todo: turn into a parameter
		int inAutoCDataThreshold = 1000;

		// If no cdata limit was set, or it's set and we're below
		// it, go ahead and add as regular content
		if( inAutoCDataThreshold < 0 ||
			(inNewText.length() < inAutoCDataThreshold )
			)
		{
			newChild.addContent( inNewText );
		}
		// Otherwise we do need to use CDATA
		else
		{
			newChild.addContent( new CDATA(inNewText) );
		}


		// Add it to it's parent

		// Now attach it to it's parent
		directParent.addContent( newChild );

//		System.err.println( "JDOMHelper:addSimpleTextToNewPath:"
//			+ " inSourceElem=" + inSourceElem.getName()
//			+ " inPath=" + inPath
//			+ " inNewText=" + inNewText
//			+ " newChild=" + newChild.getName()
//			+ " direct parent=" + directParent.getName()
//			);
		// Return what we created
		return newChild;

	}


	// Delete an element
	// Return the deleted element on success,
	// null on failure

	public Element removeElementByPath( String target )
	{
		return removeElementByPath( getJdomElement(), target );
	}

	public static Element removeElementByPath( Element sourceElem,
		String target
		)
	{
		// Find the node we're to remove
		Element endChild = findElementByPath( sourceElem, target );
		if( endChild == null )
			return null;

		// Find it's parent
		Element directParent = endChild.getParent();
		if( directParent == null )
			return null;

		// Tell the parent to delete this child, by reference
		boolean success = directParent.removeContent( endChild );

		if( success )
			return endChild;
		else
			return null;
	}


	/***************************************************
	 *
	 *      XSLT and Transforms
	 *
	 ****************************************************/
	private void __separator__XSLT_and_Transforms_ () {}

//	public static String getStyleSheetPath( String inSheetPath )
//	{
//		return "";
//	}

	// Given a jdom helper node and a style sheet, transform it
	// into a new document
	// This is just a wrapper
	// These just convert jdom helper to a true jdom element
	public static Document xsltElementToDoc( JDOMHelper inElem,
			String inStyleSheetName
		)
		throws JDOMHelperException
	{
		Element lElem = inElem.getJdomElement();
		return xsltElementToDoc( lElem, inStyleSheetName );
	}
	// The non-static versions
	public Document xsltElementToDoc( String inStyleSheetName )
		throws JDOMHelperException
	{
		return xsltElementToDoc( inStyleSheetName, null );
	}
	public Document xsltElementToDoc( String inStyleSheetName,
		Hashtable inParamsHash
		)
		throws JDOMHelperException
	{
		Element lElem = getJdomElement();
		return xsltElementToDoc( lElem, inStyleSheetName, inParamsHash );
	}

	// Given a jdom element and a style sheet, transform it
	// into a new document
	public static Document xsltElementToDoc( Element inElem,
			String inStyleSheetName
		)
		throws JDOMHelperException
	{
		return xsltElementToDoc( inElem, inStyleSheetName, null );
	}

	// Given a jdom element and a style sheet, transform it
	// Pass in the parameters if any are set
	// into a new document
	public static Document xsltElementToDoc( Element inElem,
			String inStyleSheetName,
			Hashtable inParamsHash
		)
		throws JDOMHelperException
	{
		Document srcDoc = null;
		if( inElem.isRootElement() )
			srcDoc = inElem.getDocument();
		else
		{
			Element newElem = (Element)inElem.clone();
			newElem.detach();
			srcDoc = new Document( newElem );
		}

		return xsltDocToDoc( srcDoc, inStyleSheetName, inParamsHash );
	}

	public static Document xsltDocToDoc(Document inDoc, String inStyleSheet)
		throws JDOMHelperException
	{
		return xsltDocToDoc( inDoc, inStyleSheet, null );
	}
	public static Document xsltDocToDoc(Document inDoc,
			String inStyleSheet,
			Hashtable inParamsHash
		)
		throws JDOMHelperException
	{
		try
		{

			File lStyleFile = NIEUtil.findInputFile( inStyleSheet );

			Transformer transformer = TransformerFactory.newInstance()
				.newTransformer(new StreamSource(lStyleFile));
			JDOMResult lOutResult = new JDOMResult();

			// Add the parameters, if we were given any
			if( inParamsHash != null )
			{
				Set keys = inParamsHash.keySet();
				for( Iterator it = keys.iterator() ; it.hasNext() ; )
				{
					String key = (String) it.next();
					String value = (String) inParamsHash.get( key );
					transformer.setParameter( key, value );
				}
			}

			// Do the actual work and return the answer
			transformer.transform(new JDOMSource(inDoc), lOutResult);
			return lOutResult.getDocument();
		}
		catch (TransformerException e)
		{
			throw new JDOMHelperException("XSLT Transformation failed: " + e);
		}
		catch (Exception e2)
		{
			throw new JDOMHelperException("XSLT Transformation, setup problem"
				+ e2
				);
		}
	}



	/***************************************************
	 *
	 *      Printing and Debugging
	 *
	 ****************************************************/
	private void __separator__Printing_and_Debugging_ () {}

	public void printAttributeList( String target )
	{
		List attrs = getListFromAttribute( target );
		System.out.println( getElementName() +
			" attr list '" + target + "':"
			);
		Iterator it = attrs.iterator();
		while( it.hasNext() )
		{
			System.out.println( "\t'" + (String)it.next() + "'" );
		}
	}

	public void listKids( )
	{
		listKids( getJdomElement() );
	}

	public static void listKids( Element elem )
	{
		List kids = elem.getChildren();
		System.out.println( "Listing " + kids.size() + " children." );
		for( int i=0; i<kids.size(); i++ )
		{
			System.out.println( "\t" + (i+1) + ": " +
				((Element)kids.get(i)).getName()
				);
		}
	}

	public void print()
	{
		print( myElement );
	}
	public static void print( Element elem )
	{
		// Get compact outputter
		XMLOutputter xo = new XMLOutputter( "    ", true );

		//xo.setTrimText(true);
		xo.setTextNormalize(true);

		try
		{
			xo.output( elem, System.out );
		}
		catch (Exception e)
		{
			System.out.println( "Error outputting jdom element. ");
		}
	}

	public String JDOMToString()
	{
		return JDOMToString( this.getJdomElement(), false );
	}
	public String JDOMToString( boolean inPrettyFormat )
	{
		return JDOMToString( this.getJdomElement(), inPrettyFormat );
	}
	public static String JDOMToString( Document inDoc )
	{
		return JDOMToString( inDoc.getRootElement(), false );
	}
	public static String JDOMToString( Document inDoc, boolean inPrettyFormat )
	{
		return JDOMToString( inDoc.getRootElement(), inPrettyFormat );
	}
	public static String JDOMToString( Element elem )
	{
		return JDOMToString( elem, false );
	}
	public static String JDOMToString( Element elem, boolean inPrettyFormat )
	{
		if( elem == null )
		{
			System.err.println( "ERROR: JDOMHelper:JDOMToString:"
				+ " Was passed a NULL element."
				);
			return "<null/>";
		}

		XMLOutputter xo = null;
		if( ! inPrettyFormat )
		{
			// Get compact outputter
			xo = new XMLOutputter();
			//xo.setTrimText(true);
			xo.setTextNormalize(true);
		}
		else
		{
			// Get indented outputter
			xo = new XMLOutputter( "  ", true );
		}

		// Get a stream to string buffer
		StringWriter sw = new StringWriter();

		// Run the output
		try
		{
			xo.output( elem, sw );
			sw.close();
		}
		catch (Exception e)
		{
			return "<error_converting_to_string/>";
		}

		// Return the string
		return sw.toString();

	}

	public void writeToFile( String fileName )
	{
		writeToFile( getJdomElement(), fileName );
	}
	public static void writeToFile( Element inElem, String inFileName )
	{

		if( inElem == null || inFileName == null )
			return;
			// Todo: complain

		OutputStream outStream = null;
		File theFile = null;
		try
		{
			theFile = new File(
				System.getProperty( "user.dir" ), inFileName
				);
			outStream = new FileOutputStream( theFile );
		}
		catch (Exception e)
		{
			theFile = new File( inFileName );
			try
			{
				outStream = new FileOutputStream( theFile );
			}
			catch (Exception e2)
			{
				System.err.println( "Error outputting xml to file\n" + e2 );
				return;
			}
		}

		// OutputStream tmpOut = new BufferedOutputStream( outStream );
		// Writer writer = new OutputStreamWriter( tmpOut );

		// Get compact outputter
		XMLOutputter xo = new XMLOutputter( "    ", true );
		//XMLOutputter xo = new XMLOutputter( "    ", true, "ISO-8859-1" );

		//xo.setTrimText(true);
		xo.setTextNormalize(true);

		try
		{
			//xo.output( inElem, writer );
			xo.output( inElem, outStream );
		}
		catch (Exception e)
		{
			System.out.println( "Error outputting jdom element. ");
		}

		//try { writer.close(); } catch (Exception e) { }
		//try { tmpOut.close(); } catch (Exception e) { }
		try { outStream.close(); } catch (Exception e) { }

	}


	/***************************************************
	 *
	 *		Main
	 *
	 ***************************************************/

	public static void main(String[] args)
	{
		System.out.println( "testing cloneable" );

		/***
		if( args.length < 1 )
		{
			System.out.println( "Error: syntax:\nclass query1 query2 ..." );
			System.exit(1);
		}
		***/

		String sampleDoc =
			"<food>" +
			"	<healthy>" +
			"		<fruit>apple</fruit>" +
			"		<fruit>orange</fruit>" +
			"		<fruit>bannana</fruit>" +
			"		<fruit>pear</fruit>" +
			"		<fruit>blueberry</fruit>" +
			"		<fruit>rasberry</fruit>" +
			"	</healthy>" +
			"	<healthy>" +
			"		<fruit>kiwi</fruit>" +
			"		<fruit>mango</fruit>" +
			"		<fruit>pineapple</fruit>" +
			"	</healthy>" +
			"</food>";

		JDOMHelper jh = null;
		try
		{
			jh = new JDOMHelper( sampleDoc, null );
		}
		catch (Exception e)
		{
			System.out.println( "Error creating test document: " + e );
			System.exit(1);
		}

		System.out.println( "Have original" );

		JDOMHelper jh2 = (JDOMHelper)jh.clone();

		System.out.println( "Have clone" );

		//System.out.println( "======== Sample Doc ===========" );
		//jh.print();

		/***
		for( int i = 0; i<args.length; i++ )
		{
			String query = args[i];
			System.out.println( "==============================" );
			System.out.println( "Trying '" + query + "'" );
			Element elem = jh.findElementByPath( query );
			if( elem == null )
				System.out.println( "NONE FOUND" );
			else
				System.out.println( JDOMHelper.JDOMToString( elem ) );
		}
		***/
	}
}
